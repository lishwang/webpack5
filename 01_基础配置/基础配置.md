[学习文档](http://xxpromise.gitee.io/webpack5-docs/base/css.html#_1-%E4%B8%8B%E8%BD%BD%E5%8C%85-2)

### webpack5的基础配置

- [webpack](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.webpackjs.com%2Fconcepts%2F)是一个打包工具，打包js、css、图片、html等，它可以分析整个项目的文件结构，确认文件之间的依赖，将文件合成、压缩、加入hash等，生成最终项目文件。webpack把所有文件当成模块，但是webpack内置默认的加载器是处理js的，如果要处理其他类型的文件则需要引入不同的loader加载器，用来转化其他文件进行编译打包。webpack通过使用babel-loader使用Babel ；
- webpack和babel通常配合起来使用，babel是js编译工具,能将es6或者一些特殊语法做一些转换，只做文件转义，不做文件整合。webpack是一个打包工具，内置只能处理js，但是它可以加载很多的loader处理css,img,ts,vue等其他文件,最终输出js文件。webpack通过使用babel-loader使用Babel 。

##### 起步（通过控制台输入命令做webpack简单的打包，只能打包 js 和 json 文件）

1. 新建一个空文件夹；
2. 根目录创建 src 文件夹，src 内部创建 main.js 入口文件；
3. src 文件内创建 js 文件夹，内部创建两个 js 文件，并通过 import 与 export default 默认引入和导出到 main.js 入口文件；
4. `npm init -y `  初始化包管理工具；
5. `npm install -D webpack webpack-cli`  安装开发依赖 webpack；
6. 执行 `npx webpack ./src/main.js --mode=development`  使用 webpack 打包项目，打包后的文件路径为 `./dist/main.js` ；
7. 根目录创建 static 文件夹，内部创建 index.html 文件，并通过 script 引入打包后的文件路径即可执行；

##### webpack的配置文件

1. 在项目根目录下创建 `webpack.config.js` 文件；

   - **所有的配置文件都是在 nodejs 平台运行的，因此配置文件内部采用的模块化采用的都是 commonJs 的模块化（module.export={ xxx }）;**

2. 配置文件中的主要内容；

   - 入口

     - 打包的入口文件路径，一般是相对路径；

     ```
     module.export = {
     	entry: './src/main.js';
     }
     ```

   - 输出

     - 输出文件路径一般是绝对路径；
     - 输出属性值一般是一个对象；
     - **输出配置文件中设置 clean 为 true ，即可实现自动清空上次打包的内容**；但是在 webpack4 中需要在插件中实现；

     ```
     const path = require('path'); // nodejs模块，专门用来处理路径问题
     
     module.export = {
         output: {
             // 文件的输出路径（输出文件夹）
             path: path.resolve(__dirname, 'dist'), // path.resolve() 返回一个绝对路径；__dirname 当前文件的文件夹的目录；'dist' 输出的文件夹名称为 dist；
             // 输出文件名
             filename: 'main.js',
             // 自动清空上次打包的内容
         	clean: true,
         }
     }
     ```

   - 加载器

     - 处理样式资源

       - 下载loader

         - css-loader  负责将 Css 文件编译成 Webpack 能识别的模块（commonjs）到 js 中；
         - style-loader  会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容，并添加到 html 文件中使样式生效；

         ```
         npm i css-loader style-loader -D
         ```

       - 注意：loader 的执行顺序：从右到左（从下到上）

       - use的属性值是一个数组，可以使用多个 loader ；loader属性 的属性值是一个字符串，只能使用一个 loader ；

     ```
     module.export = {
     	module: {
     		rules: [
     			{
                     test: /\.css$/, // 检测css文件
                     // loader 的执行顺序：从右到左（从下到上）
                     use: [
                       'style-loader', // 将 js 中的css代码通过创建style标签添加到html文件中使样式生效；
                       'css-loader', // 将 css 资源编译成 commonjs 的模块到js 中；
                     ]
                 }
     		]
     	}
     }
     ```

     - 处理图片资源

       - 过去在 Webpack4 时，我们处理图片资源通过 `file-loader` 和 `url-loader` 进行处理，现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源，不需要安装loader；
       - 另外，对于较小的图片可以将其转换成base64格式的字符串，减少浏览器请求，优化性能；
       - 可以设置生成的图片名字以及打包输出的图片所在的目录，做到**打包输出的文件归类放置**；

       ```
       module.export = {
       	module: {
       		rules: [
       			{
                       test: /\.(png|jpe?g|gif|webp)$/,
                       type: "asset",
                       parser: {
                         // 如果图片不大于100kb，将会被转化成base64格式的图片字符串
                         dataUrlCondition: {
                           maxSize: 100 * 1024 // 100kb
                         }
                       },
                       generator: {
                         // 设置生成的图片名字以及打包输出的图片所在的目录，做到打包输出的文件归类放置；
                         // hash 图片打包后会有一个唯一的id（图片默认情况下打包后的名字），这个id在webpack中被称为hash值；
                         // [hash:6] 表示取hash值的前六位最为图片的名字；
                         // ext 文件扩展名，之前是 .png 打包后 ext 还是 .png；
                         // query 查询参数，如果在url地址中写了其他参数，这里会携带上；
                         filename: 'static/images/[hash:6][ext][query]'
                       },
                   },
       		]
       	}
       }
       ```

       

     - 处理字体图标 以及 其他资源（不做资源内容的处理，原封不动的打包输出，例如音频、视频资源等）

       - 字体图标不需要转base64，因此配置属性 `type: "asset/resource"`  将文件原封不动的打包输出；

       ```
       module.export = {
       	module: {
       		rules: [
       			{
                       test: /\.(ttf|woff2?|mp3|mp4|avi)$/,
                       type: "asset/resource", // 将文件原封不动的打包输出
                       generator: {
                         // 设置打包输出的文件名字以及打包输出的文件所在的目录
                         filename: 'static/media/[hash:6][ext][query]'
                       },
                    },
       		]
       	}
       }
       ```

       

       - 

     - 

       

   - 插件

     - 配置 HTML 模板

       - 之前我们是手动引入的打包后的 js 资源，但如果 webpack 配置中修改了 打包输出路径，还要手动修改 html 文件中引入的 js 路径；因此可以借助插件来实现打包后 js 文件的自动引入；

       - 使用方式：

         1. 安装插件   `npm install --save-dev html-webpack-plugin`  ;
         2. webpack 配置文件中配置插件

         ```
         const HtmlWebpackPlugin = require('html-webpack-plugin');
         
         module.exports = {
         // 插件
           plugins: [
             // 配置 HTML 模板，可以借助插件来实现打包后 js 文件的自动引入到 html 文件中
             new HtmlWebpackPlugin({
             	// 模板：以 public/index.html 为模板，创建新的html文件，并打包到 dist 文件下；
               	// 这个新的html文件有两个特点：1、DOM结构与模板中的一致；2、会自动引入打包后的资源；
               	template: './static/index.html',
             }),
           ],
         }
         ```

       

     - 

     ```
     module.export = {
         plugins: [
         	// 插件
         ]
     }
     ```

     

   - 模式

     - 模式有两种：development 和 production

     ```
     module.export = {
     	mode: 'development'
     }
     ```

     

3. 由于写了配置文件，因此可以直接执行 npx webpack  即可完成简单的打包；





--------------------

-----------------

-------------------



### Eslint

##### [官网](https://eslint.bootcss.com/docs/user-guide/configuring)

##### Eslint的配置文件

###### 配置文件由很多种写法：

1、新建文件，位于项目根目录

- `.eslintrc`
- `.eslintrc.js`
- `.eslintrc.json`
- 区别在于配置格式不一样

2、`package.json` 中 `eslintConfig`：不需要创建文件，在原有文件基础上写；

ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可；

###### 以 `.eslintrc.js` 语法为例，书写 Eslint 配置文件

```
module.exports = {
  // 解析选项
  parserOptions: {},
  // 具体检查规则
  rules: {},
  // 继承其他规则
  extends: [],
  // ...
  // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring
};
```

- parserOptions 解析选项

```
parserOptions: {
  ecmaVersion: 6, // ES 语法版本，表示ES6
  sourceType: "module", // ES 模块化
  ecmaFeatures: { // ES 其他特性
    jsx: true // 如果是 React 项目，就需要开启 jsx 语法
  }
}
```

- rules 具体规则
  1. `"off"` 或 `0` - 关闭规则
  2. `"warn"` 或 `1` - 开启规则，使用警告级别的错误：`warn` (不会导致程序退出)
  3. `"error"` 或 `2` - 开启规则，使用错误级别的错误：`error` (当被触发的时候，程序会退出)
  4. 更多规则详见：[规则文档](https://eslint.bootcss.com/docs/rules/)

```
rules: {
  semi: "error", // 禁止使用分号
  'array-callback-return': 'warn', // 强制数组方法的回调函数中有 return 语句，否则警告
  'default-case': [
    'warn', // 要求 switch 语句中有 default 分支，否则警告
    { commentPattern: '^no default$' } // 允许在最后注释 no default, 就不会有警告了
  ],
  eqeqeq: [
    'warn', // 强制使用 === 和 !==，否则警告
    'smart' // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告
  ],
}
```

- extends 继承

  开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。现有以下较为有名的规则：

  1. [Eslint 官方的规则：`eslint:recommended`
  2. [Vue Cli 官方的规则](https://github.com/vuejs/vue-cli/tree/dev/packages/@vue/cli-plugin-eslint)：`plugin:vue/essential`
  3. [React Cli 官方的规则](https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app)：`react-app`

```
// 例如在React项目中，我们可以这样写配置
module.exports = {
  extends: ["react-app"], // 继承 react cli 官方的 Eslint规则
  rules: {
    // 我们的规则会覆盖掉react-app的规则
    // 所以想要修改规则直接改就是了
    eqeqeq: ["warn", "smart"], // 新增规则 或者 覆盖掉继承的规则
  },
};
```

##### webpack 处理 Eslint  代码

- Eslint 在 webpack4 中是用 loader 来处理的；但在 webpack5 中用 插件 处理的；

###### webpack5 用 插件 处理 Eslint

1. 安装  `npm i eslint-webpack-plugin eslint -D`  ；

2. webpack.config.js 配置

   ```
   # webpack.config.js 文件内
   const ESLintWebpackPlugin = require("eslint-webpack-plugin");
   
   plugins: [
       new ESLintWebpackPlugin({
         // 指定检查文件的根目录
         context: path.resolve(__dirname, "src"),
       }),
   ],
   ```

3. 在文件根目录创建 Eslint 的配置文件（以 .eslintrc.js 为例）

   ```
   // 以下eslint配置举例
   module.exports = {
     // 继承 Eslint 规则
     extends: ["eslint:recommended"], // 继承 Eslint 官方的规则
     // 环境变量
     env: {
       node: true, // 启用node中全局变量
       browser: true, // 启用浏览器中全局变量，比如：window、console等
     },
     parserOptions: {
       ecmaVersion: 6, // 语法环境：ES6
       sourceType: "module", // ES module
     },
     rules: {
       "no-var": 2, // 不能使用 var 定义变量，否则报错误级别的错误，2 等同于 error
     },
   };
   ```

4. 如果代码中使用  var  来声明变量，如果 vscode 没有安装 Eslint 插件，则会在编译代码时报错；如果 vscode 安装了 eslint 插件，则会在书写代码时就会报错，因此建议在 vscode 中安装 eslint 插件；

5. `.eslintignore`  文件，用于配置 Eslint 忽略检查的文件；比如：通过webpack打包后的dist文件内不需要被eslint检查，因此可忽略；

   ```
   // .eslintignore 文件内
   # 忽略dist目录下所有文件
   dist
   ```

   

6. 可以在  settings.json  文件内配置是否在保存时修复 eslint 发现的语法错误；

   ```
   // settings.json 文件内
   {
   	"liveServer.settings.donotShowInfoMsg": true,
   	"explorer.confirmDelete": false,
   	"emmet.excludeLanguages": ["markdown"],
   	"liveServer.settings.host": "192.168.37.60",
   	"explorer.confirmDragAndDrop": false,
   	"workbench.editor.enablePreview": false,
   	"cssrem.rootFontSize": 80,
   	"window.zoomLevel": 2,
   	"editor.minimap.enabled": false,
   	"[vue]": {
   		"editor.defaultFormatter": "octref.vetur"
   	},
   	"[javascript]": {
   		"editor.defaultFormatter": "vscode.typescript-language-features"
   	},
   	"eslint.validate": ["javascript", "javascriptreact"],
   	"vetur.ignoreProjectWarning": true,
   	"vetur.format.defaultFormatter.js": "vscode-typescript",
   	"vetur.format.defaultFormatter.html": "js-beautify-html",
   	"vetur.format.defaultFormatterOptions": {
   
   		"js-beautify-html": {
   			"wrap_line_length": 80, // Wrap attributes to new lines [auto|force|force-aligned|force-expand-multiline] ["auto"]
   			// "wrap_attributes": "force-expand-multiline" // DOM 标签超过两个换行
   		}
   	},
   	"editor.tabSize": 2,
   	"git.ignoreLimitWarning": true,
   	"editor.codeActionsOnSave": {
   		"source.fixAll.eslint": true, // 保存时是否自动修复eslint检测报错的代码
   	},
   	"git.confirmSync": false,
   	"eslint.quiet": true,
   	"javascript.format.insertSpaceBeforeFunctionParenthesis": true,
   	"typescript.format.insertSpaceAfterConstructor": true,
   	"typescript.format.insertSpaceBeforeFunctionParenthesis": true,
   	"javascript.preferences.quoteStyle": "single",
   	"javascript.format.insertSpaceAfterConstructor": true,
   	"typescript.preferences.quoteStyle": "single",
   	// "html.format.wrapAttributes": "force-expand-multiline", // DOM 标签超过两个换行
   	"editor.formatOnSave": true,
   	"prettier.vueIndentScriptAndStyle": true,
   	"prettier.singleQuote": true,
   	"prettier.useTabs": true,
   	"prettier.printWidth": 100,
   	"eslint.workingDirectories": [
   		".eslintrc.js",
   		{
   			"mode": "auto"
   		}
   	],
   	"[json]": {
   		"editor.defaultFormatter": "esbenp.prettier-vscode"
   	},
   	"editor.fontSize": 12,
   	"[html]": {
   		"editor.defaultFormatter": "vscode.html-language-features"
   	},
   	"javascript.updateImportsOnFileMove.enabled": "always",
   	"vetur.validation.template": false,
   	"eslint.codeActionsOnSave.rules": null
   }
   
   ```






----

----

---



### Babel

##### [官网](https://babeljs.io/docs/en/)

- JavaScript 编译器。主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中；
- [babel](https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2F)是一个JS编译器，用来将ES6/ES7等语法转换为ES5语法（浏览器不认识的语法编译成浏览器认识的语法），从而能够使代码在大部分浏览器中运行。但是babel转换语法时有一些新的api是不转化的，比如promise、Object.assign等，所以babel还提供了很多插件，如babel-polyfill。
- **webpack和babel通常配合起来使用，babel是js编译工具,能将es6或者一些特殊语法做一些转换，只做文件转义，不做文件整合。webpack是一个打包工具，内置只能处理js，但是它可以加载很多的loader处理css,img,ts,vue等其他文件,最终输出js文件。webpack通过使用babel-loader使用Babel 。**

##### Babel 的配置文件

###### Babel 的配置文件由很多种写法：Babel 会查找和自动读取它们，所以以下配置文件只需要存在一个即可

1. 新建文件，位于项目根目录
   - `babel.config.js`
   - `babel.config.json`
   - `.babelrc`
   - `.babelrc.js`
   - `.babelrc.json`
2. 不需要创建文件，在原有文件基础上写
   - `package.json`  中 `babel` ；

###### 以 `babel.config.js` 配置文件为例

```
module.exports = {
	// 预设
  	presets: ["@babel/preset-env"],
};
```

- presets 预设，简单理解：就是一组 Babel 插件, 扩展 Babel 功能；
  1. `@babel/preset-env`: 一个智能预设，允许您使用最新的 JavaScript ；
  2. `@babel/preset-react`：一个用来编译 React jsx 语法的预设 ；
  3. `@babel/preset-typescript`：一个用来编译 TypeScript 语法的预设 ；

##### webpack 处理 Babel 代码

###### webpack5 用 loader 处理 Babel 代码

1. 下载包

   ```
   npm i babel-loader @babel/core @babel/preset-env -D
   ```

2. 定义 Babel 配置文件，以 `babel.config.js` 配置文件为例

   ```
   module.exports = {
   	// 预设
     	presets: ["@babel/preset-env"],
   };
   ```

3. 在 webpack 的配置文件中配置 loader 处理 Babel 代码

   ```
   module: {
       rules: [
       	{
               test: /\.js$/,
               exclude: /node_modules/, // 排除 node_modules 代码不编译
               loader: "babel-loader",
               // options: {
               // 		presets: ["@babel/preset-env"],  // 如果在 webpack 的配置文件中添加了babel预设的配置，就不需要在 外面的 babel 配置文件中再配置了；
               // },
           },
       ]
   }
   ```

4. webpack 重新编译，执行 `npx webpack ` ；查看效果：例如：函数形参中 扩展运算符 改为 arguments 接收参数；



---

---

---



### 开发服务器&自动化

- 每次写完代码都需要手动输入指令 `npx webpack` 才能编译代码，太麻烦了，我们希望一切自动化；

##### 使用：

1. 安装： `npm i webpack-dev-server -D` ;

2. 在webpack中配置

   ```
   module.exports = {
   	// 开发服务器，需要运行 npx webpack serve 才能启动开发服务器，不会生成打包后的文件，而是在内存中编译打包的，而且修改完代码后自动打包且更新浏览器展示
       devServer: {
           host: "localhost", // 启动服务器域名
           port: "3000", // 启动服务器端口号
           open: true, // 是否自动打开浏览器
       },
   }
   ```

3. 运行指令 `npx webpack serve`  ，运行旧指令是不会启动开发服务器的，**注意：新指令不会生成打包后的文件，而是在内存中编译打包的，而且修改完代码后自动打包且更新浏览器展示；**





---

---

---



### 生产模式下webpack配置

##### 生产模式下的webpack配置文件调整

###### 代码中调整步骤：

1. 根目录新建 config 文件夹，将webpack的配置文件（生产模式下仿照开发模式下的配置文件进行配置）移入到 config 文件内；

2. 调整 两种模式下的 webpack 配置文件内的路径；

   - 相对路径不用调整，因为webpack的配置文件运行时还是在根目录；
   - 绝对路径需要加上 `../` ；

3. 对于开发模式下的webpack配置文件的调整：

   - 绝对路径需要加上 `../` ；
   - 输出路径改为` path: undefined `，也可以不改；（ 配置了开发服务器后，不会真正的有文件输出，而是在内存中打包的，因此可以不写输出路径，也不需要配置clean来清空上次打包内容，但是输出文件名要写）
   - 执行指令 `npx webpack serve --config ./config/webpack.dev.js`  打包并自动运行到浏览器；

4. 对于生产模式下的webpack配置文件的调整：

   - 绝对路径需要加上 `../` ；
   - 生产模式不需要devServer（配置的开发服务器），要删掉；
   - ` mode: production` ;
   - 执行指令  `npx webpack --config ./config/webpack.prod.js`  打包；

5. 在 `package.json` 文件内配置运行脚本指令快捷键；

   ```
   "scripts": {
       "start": "npm run dev", // 直接执行 npm start 即可运行开发模式的项目打包；
       "dev": "webpack serve --config ./config/webpack.dev.js", // 开发模式的项目打包；
       "build": "webpack --config ./config/webpack.prod.js" // 生产模式的项目打包；
   },
   ```

##### 提取 css 成单独的文件

- Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式，这样对于网站来说，会出现闪屏现象，用户体验不好；我们应该是单独的 Css 文件，通过 link 标签加载性能才好；

- MiniCssExtractPlugin 插件的使用：

  1. 安装包

     ```
     npm i mini-css-extract-plugin -D
     ```

  2. webpack.prod.js 文件内使用该插件：

     ```
     # 1、引入
     const MiniCssExtractPlugin = require("mini-css-extract-plugin");
     
     # 2、删掉module中的 style-loader 改成 MiniCssExtractPlugin.loader；例如：
     module: {
         rules: [
           {
             // 用来匹配 .css 结尾的文件
             test: /\.css$/,
             use: [
             	"style-loader", // 这个loader会动态创建style标签，将 js 中的css代码通过创建的style标签添加到html文件中使样式生效；
                 MiniCssExtractPlugin.loader, // 把css文件提取成单独的文件，所以不需要引入style-loader来创建style标签了；
                 "css-loader"
             ],
           },
         ],
     }
     
     # 3、配置plugins
     plugins: [
     	// 提取css成单独文件，并结合 HtmlWebpackPlugin 插件，可以实现打包后 css 自动通过 link 标签引入到 html 文件中；
         new MiniCssExtractPlugin({
           // 定义输出文件名和目录
           filename: "static/css/main.css",
         }),
     ]
     ```

##### css 兼容性处理

- js 的兼容性问题（ES6+ => ES5）由 babel 处理，而样式也有兼容性问题，比如浏览器的兼容；

-  postcss-loader 的使用步骤：

  1. 安装包

     ```
     npm i postcss-loader postcss postcss-preset-env -D
     ```

  2. webpack.prod.js 文件内使用该loader：

     ```
     module: {
         rules: [
         	{
                 test: /\.less$/,
                 use: [
                   MiniCssExtractPlugin.loader,
                   "css-loader",
                   // postcss-loader 必须使用在  "css-loader"  之前，且在  "less-loader"  等loader之后；
                   // 如果loader需要额外的配置，需要将该loader写成对象的形式；
                   {
                     loader: "postcss-loader",
                     options: {
                       postcssOptions: {
                         plugins: [
                           "postcss-preset-env", // 能解决大多数样式兼容性问题
                         ],
                       },
                     },
                   },
                   "less-loader",
                 ],
             },
         ]
     }
     ```

  3. **注意：postcss-loader 必须使用在  "css-loader"  之前，且在  "less-loader"  等loader之后；**

  4. 可以用 user-select 进行测试；

     ```
     // 打包后生成的兼容性样式
     -webkit-user-select: none;
     -moz-user-select: none;
     user-select: none;
     ```

- 配置浏览器兼容程度：

  - 可以在 `package.json` 文件中添加 `browserslist` 来控制样式的兼容性做到什么程度；更多的 `browserslist` 配置，查看[browserslist 文档](https://github.com/browserslist/browserslist) ；

  ```
  // 比较常见的浏览器兼容程度的配置
  {
    // 满足以下条件的交集的浏览器才做兼容
    "browserslist": [
        "last 2 version",  // 所有浏览器最近的两个版本
        "> 1%",  // 市场占有率大于1%的浏览器
        "not dead" // 还在维护的浏览器
    ]
  }
  ```

##### css 压缩

- CssMinimizerWebpackPlugin 插件的使用步骤：

  1. 安装包

     ```
     npm install css-minimizer-webpack-plugin --save-dev
     ```

  2. webpack.prod.js 中使用

     ```
     const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
     
     // 插件
     plugins: [
     	// css压缩
         new CssMinimizerPlugin(),
     ]
     ```

##### html 、js 压缩

- 只要设置 mode 为 production 生产模式，默认开启 html 压缩 和 js 压缩，不需要额外配置；
