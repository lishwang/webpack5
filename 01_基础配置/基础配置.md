[学习文档](http://xxpromise.gitee.io/webpack5-docs/base/css.html#_1-%E4%B8%8B%E8%BD%BD%E5%8C%85-2)

### webpack5的基础配置

##### 起步（通过控制台输入命令做webpack简单的打包，只能打包 js 和 json 文件）

1. 新建一个空文件夹；
2. 根目录创建 src 文件夹，src 内部创建 main.js 入口文件；
3. src 文件内创建 js 文件夹，内部创建两个 js 文件，并通过 import 与 export default 默认引入和导出到 main.js 入口文件；
4. `npm init -y `  初始化包管理工具；
5. `npm install -D webpack webpack-cli`  安装开发依赖 webpack；
6. 执行 `npx webpack ./src/main.js --mode=development`  使用 webpack 打包项目，打包后的文件路径为 `./dist/main.js` ；
7. 根目录创建 static 文件夹，内部创建 index.html 文件，并通过 script 引入打包后的文件路径即可执行；

##### webpack的配置文件

1. 在项目根目录下创建 `webpack.config.js` 文件；

   - **所有的配置文件都是在 nodejs 平台运行的，因此配置文件内部采用的模块化采用的都是 commonJs 的模块化（module.export={ xxx }）;**

2. 配置文件中的主要内容；

   - 入口

     - 打包的入口文件路径，一般是相对路径；

     ```
     module.export = {
     	entry: './src/main.js';
     }
     ```

   - 输出

     - 输出文件路径一般是绝对路径；
     - 输出属性值一般是一个对象；
     - **输出配置文件中设置 clean 为 true ，即可实现自动清空上次打包的内容**；但是在 webpack4 中需要在插件中实现；

     ```
     const path = require('path'); // nodejs模块，专门用来处理路径问题
     
     module.export = {
         output: {
             // 文件的输出路径（输出文件夹）
             path: path.resolve(__dirname, 'dist'), // path.resolve() 返回一个绝对路径；__dirname 当前文件的文件夹的目录；'dist' 输出的文件夹名称为 dist；
             // 输出文件名
             filename: 'main.js',
             // 自动清空上次打包的内容
         	clean: true,
         }
     }
     ```

   - 加载器

     - 处理样式资源

       - 下载loader

         - css-loader  负责将 Css 文件编译成 Webpack 能识别的模块（commonjs）到 js 中；
         - style-loader  会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容，并添加到 html 文件中使样式生效；

         ```
         npm i css-loader style-loader -D
         ```

       - 注意：loader 的执行顺序：从右到左（从下到上）

       - use的属性值是一个数组，可以使用多个 loader ；loader属性 的属性值是一个字符串，只能使用一个 loader ；

     ```
     module.export = {
     	module: {
     		rules: [
     			{
                     test: /\.css$/, // 检测css文件
                     // loader 的执行顺序：从右到左（从下到上）
                     use: [
                       'style-loader', // 将 js 中的css代码通过创建style标签添加到html文件中使样式生效；
                       'css-loader', // 将 css 资源编译成 commonjs 的模块到js 中；
                     ]
                 }
     		]
     	}
     }
     ```

     - 处理图片资源

       - 过去在 Webpack4 时，我们处理图片资源通过 `file-loader` 和 `url-loader` 进行处理，现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源，不需要安装loader；
       - 另外，对于较小的图片可以将其转换成base64格式的字符串，减少浏览器请求，优化性能；
       - 可以设置生成的图片名字以及打包输出的图片所在的目录，做到**打包输出的文件归类放置**；

       ```
       module.export = {
       	module: {
       		rules: [
       			{
                       test: /\.(png|jpe?g|gif|webp)$/,
                       type: "asset",
                       parser: {
                         // 如果图片不大于100kb，将会被转化成base64格式的图片字符串
                         dataUrlCondition: {
                           maxSize: 100 * 1024 // 100kb
                         }
                       },
                       generator: {
                         // 设置生成的图片名字以及打包输出的图片所在的目录，做到打包输出的文件归类放置；
                         // hash 图片打包后会有一个唯一的id（图片默认情况下打包后的名字），这个id在webpack中被称为hash值；
                         // [hash:6] 表示取hash值的前六位最为图片的名字；
                         // ext 文件扩展名，之前是 .png 打包后 ext 还是 .png；
                         // query 查询参数，如果在url地址中写了其他参数，这里会携带上；
                         filename: 'static/images/[hash:6][ext][query]'
                       },
                   },
       		]
       	}
       }
       ```

       

     - 处理字体图标 以及 其他资源（不做资源内容的处理，原封不动的打包输出，例如音频、视频资源等）

       - 字体图标不需要转base64，因此配置属性 `type: "asset/resource"`  将文件原封不动的打包输出；

       ```
       module.export = {
       	module: {
       		rules: [
       			{
                       test: /\.(ttf|woff2?|mp3|mp4|avi)$/,
                       type: "asset/resource", // 将文件原封不动的打包输出
                       generator: {
                         // 设置打包输出的文件名字以及打包输出的文件所在的目录
                         filename: 'static/media/[hash:6][ext][query]'
                       },
                    },
       		]
       	}
       }
       ```

       

       - 

     - 

       

   - 插件

     - 

     ```
     module.export = {
         plugins: [
         	// 插件
         ]
     }
     ```

     

   - 模式

     - 模式有两种：development 和 production

     ```
     module.export = {
     	mode: 'development'
     }
     ```

     

3. 由于写了配置文件，因此可以直接执行 npx webpack  即可完成简单的打包；





--------------------

-----------------

-------------------



### Eslint

##### [官网](https://eslint.bootcss.com/docs/user-guide/configuring)

##### Eslint的配置文件

###### 配置文件由很多种写法：

1、新建文件，位于项目根目录

- `.eslintrc`
- `.eslintrc.js`
- `.eslintrc.json`
- 区别在于配置格式不一样

2、`package.json` 中 `eslintConfig`：不需要创建文件，在原有文件基础上写；

ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可；

###### 以 `.eslintrc.js` 语法为例，书写 Eslint 配置文件

```
module.exports = {
  // 解析选项
  parserOptions: {},
  // 具体检查规则
  rules: {},
  // 继承其他规则
  extends: [],
  // ...
  // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring
};
```

- parserOptions 解析选项

```
parserOptions: {
  ecmaVersion: 6, // ES 语法版本，表示ES6
  sourceType: "module", // ES 模块化
  ecmaFeatures: { // ES 其他特性
    jsx: true // 如果是 React 项目，就需要开启 jsx 语法
  }
}
```

- rules 具体规则
  1. `"off"` 或 `0` - 关闭规则
  2. `"warn"` 或 `1` - 开启规则，使用警告级别的错误：`warn` (不会导致程序退出)
  3. `"error"` 或 `2` - 开启规则，使用错误级别的错误：`error` (当被触发的时候，程序会退出)
  4. 更多规则详见：[规则文档](https://eslint.bootcss.com/docs/rules/)

```
rules: {
  semi: "error", // 禁止使用分号
  'array-callback-return': 'warn', // 强制数组方法的回调函数中有 return 语句，否则警告
  'default-case': [
    'warn', // 要求 switch 语句中有 default 分支，否则警告
    { commentPattern: '^no default$' } // 允许在最后注释 no default, 就不会有警告了
  ],
  eqeqeq: [
    'warn', // 强制使用 === 和 !==，否则警告
    'smart' // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告
  ],
}
```

- extends 继承

  开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。现有以下较为有名的规则：

  1. [Eslint 官方的规则：`eslint:recommended`
  2. [Vue Cli 官方的规则](https://github.com/vuejs/vue-cli/tree/dev/packages/@vue/cli-plugin-eslint)：`plugin:vue/essential`
  3. [React Cli 官方的规则](https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app)：`react-app`

```
// 例如在React项目中，我们可以这样写配置
module.exports = {
  extends: ["react-app"], // 继承 react cli 官方的 Eslint规则
  rules: {
    // 我们的规则会覆盖掉react-app的规则
    // 所以想要修改规则直接改就是了
    eqeqeq: ["warn", "smart"], // 新增规则 或者 覆盖掉继承的规则
  },
};
```

##### webpack 处理 Eslint  代码

- Eslint 在 webpack4 中是用 loader 来处理的；但在 webpack5 中用 插件 处理的；

###### webpack5 用 插件 处理 Eslint

1. 安装  `npm i eslint-webpack-plugin eslint -D`  ；

2. webpack.config.js 配置

   ```
   # webpack.config.js 文件内
   const ESLintWebpackPlugin = require("eslint-webpack-plugin");
   
   plugins: [
       new ESLintWebpackPlugin({
         // 指定检查文件的根目录
         context: path.resolve(__dirname, "src"),
       }),
   ],
   ```

3. 在文件根目录创建 Eslint 的配置文件（以 .eslintrc.js 为例）

   ```
   // 以下eslint配置举例
   module.exports = {
     // 继承 Eslint 规则
     extends: ["eslint:recommended"], // 继承 Eslint 官方的规则
     // 环境变量
     env: {
       node: true, // 启用node中全局变量
       browser: true, // 启用浏览器中全局变量，比如：window、console等
     },
     parserOptions: {
       ecmaVersion: 6, // 语法环境：ES6
       sourceType: "module", // ES module
     },
     rules: {
       "no-var": 2, // 不能使用 var 定义变量，否则报错误级别的错误，2 等同于 error
     },
   };
   ```

4. 如果代码中使用  var  来声明变量，如果 vscode 没有安装 Eslint 插件，则会在编译代码时报错；如果 vscode 安装了 eslint 插件，则会在书写代码时就会报错，因此建议在 vscode 中安装 eslint 插件；

5. `.eslintignore`  文件，用于配置 Eslint 忽略检查的文件；比如：通过webpack打包后的dist文件内不需要被eslint检查，因此可忽略；

   ```
   // .eslintignore 文件内
   # 忽略dist目录下所有文件
   dist
   ```

   

6. 可以在  settings.json  文件内配置是否在保存时修复 eslint 发现的语法错误；

   ```
   // settings.json 文件内
   {
   	"liveServer.settings.donotShowInfoMsg": true,
   	"explorer.confirmDelete": false,
   	"emmet.excludeLanguages": ["markdown"],
   	"liveServer.settings.host": "192.168.37.60",
   	"explorer.confirmDragAndDrop": false,
   	"workbench.editor.enablePreview": false,
   	"cssrem.rootFontSize": 80,
   	"window.zoomLevel": 2,
   	"editor.minimap.enabled": false,
   	"[vue]": {
   		"editor.defaultFormatter": "octref.vetur"
   	},
   	"[javascript]": {
   		"editor.defaultFormatter": "vscode.typescript-language-features"
   	},
   	"eslint.validate": ["javascript", "javascriptreact"],
   	"vetur.ignoreProjectWarning": true,
   	"vetur.format.defaultFormatter.js": "vscode-typescript",
   	"vetur.format.defaultFormatter.html": "js-beautify-html",
   	"vetur.format.defaultFormatterOptions": {
   
   		"js-beautify-html": {
   			"wrap_line_length": 80, // Wrap attributes to new lines [auto|force|force-aligned|force-expand-multiline] ["auto"]
   			// "wrap_attributes": "force-expand-multiline" // DOM 标签超过两个换行
   		}
   	},
   	"editor.tabSize": 2,
   	"git.ignoreLimitWarning": true,
   	"editor.codeActionsOnSave": {
   		"source.fixAll.eslint": true, // 保存时是否自动修复eslint检测报错的代码
   	},
   	"git.confirmSync": false,
   	"eslint.quiet": true,
   	"javascript.format.insertSpaceBeforeFunctionParenthesis": true,
   	"typescript.format.insertSpaceAfterConstructor": true,
   	"typescript.format.insertSpaceBeforeFunctionParenthesis": true,
   	"javascript.preferences.quoteStyle": "single",
   	"javascript.format.insertSpaceAfterConstructor": true,
   	"typescript.preferences.quoteStyle": "single",
   	// "html.format.wrapAttributes": "force-expand-multiline", // DOM 标签超过两个换行
   	"editor.formatOnSave": true,
   	"prettier.vueIndentScriptAndStyle": true,
   	"prettier.singleQuote": true,
   	"prettier.useTabs": true,
   	"prettier.printWidth": 100,
   	"eslint.workingDirectories": [
   		".eslintrc.js",
   		{
   			"mode": "auto"
   		}
   	],
   	"[json]": {
   		"editor.defaultFormatter": "esbenp.prettier-vscode"
   	},
   	"editor.fontSize": 12,
   	"[html]": {
   		"editor.defaultFormatter": "vscode.html-language-features"
   	},
   	"javascript.updateImportsOnFileMove.enabled": "always",
   	"vetur.validation.template": false,
   	"eslint.codeActionsOnSave.rules": null
   }
   
   ```

   

