[学习文档](http://xxpromise.gitee.io/webpack5-docs/base/css.html#_1-%E4%B8%8B%E8%BD%BD%E5%8C%85-2)

# webpack5的基础配置

- [webpack](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.webpackjs.com%2Fconcepts%2F)是一个打包工具，打包js、css、图片、html等，它可以分析整个项目的文件结构，确认文件之间的依赖，将文件合成、压缩、加入hash等，生成最终项目文件。webpack把所有文件当成模块，但是webpack内置默认的加载器是处理js的，如果要处理其他类型的文件则需要引入不同的loader加载器，用来转化其他文件进行编译打包。webpack通过使用babel-loader使用Babel ；
- webpack和babel通常配合起来使用，babel是js编译工具,能将es6或者一些特殊语法做一些转换，只做文件转义，不做文件整合。webpack是一个打包工具，内置只能处理js，但是它可以加载很多的loader处理css,img,ts,vue等其他文件,最终输出js文件。webpack通过使用babel-loader使用Babel 。

### 起步（通过控制台输入命令做webpack简单的打包，只能打包 js 和 json 文件）

1. 新建一个空文件夹；
2. 根目录创建 src 文件夹，src 内部创建 main.js 入口文件；
3. src 文件内创建 js 文件夹，内部创建两个 js 文件，并通过 import 与 export default 默认引入和导出到 main.js 入口文件；
4. `npm init -y `  初始化包管理工具；
5. `npm install -D webpack webpack-cli`  安装开发依赖 webpack；
6. 执行 `npx webpack ./src/main.js --mode=development`  使用 webpack 打包项目，打包后的文件路径为 `./dist/main.js` ；
7. 根目录创建 static 文件夹，内部创建 index.html 文件，并通过 script 引入打包后的文件路径即可执行；

### webpack的配置文件

1. 在项目根目录下创建 `webpack.config.js` 文件；

   - **所有的配置文件都是在 nodejs 平台运行的，因此配置文件内部采用的模块化采用的都是 commonJs 的模块化（module.export={ xxx }）;**

2. 配置文件中的主要内容；

   - 入口

     - 打包的入口文件路径，一般是相对路径；

     ```
     module.export = {
     	entry: './src/main.js';
     }
     ```

   - 输出

     - 输出文件路径一般是绝对路径；
     - 输出属性值一般是一个对象；
     - **输出配置文件中设置 clean 为 true ，即可实现自动清空上次打包的内容**；但是在 webpack4 中需要在插件中实现；

     ```
     const path = require('path'); // nodejs模块，专门用来处理路径问题
     
     module.export = {
         output: {
             // 文件的输出路径（输出文件夹）
             path: path.resolve(__dirname, 'dist'), // path.resolve() 返回一个绝对路径；__dirname 当前文件的文件夹的目录；'dist' 输出的文件夹名称为 dist；
             // 输出文件名
             filename: 'main.js',
             // 自动清空上次打包的内容
         	clean: true,
         }
     }
     ```

   - 加载器

     - 处理样式资源

       - 下载loader

         - css-loader  负责将 Css 文件编译成 Webpack 能识别的模块（commonjs）到 js 中；
         - style-loader  会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容，并添加到 html 文件中使样式生效；

         ```
         npm i css-loader style-loader -D
         ```

       - 注意：loader 的执行顺序：从右到左（从下到上）

       - use的属性值是一个数组，可以使用多个 loader ；loader属性 的属性值是一个字符串，只能使用一个 loader ；

     ```
     module.export = {
     	module: {
     		rules: [
     			{
                     test: /\.css$/, // 检测css文件
                     // loader 的执行顺序：从右到左（从下到上）
                     use: [
                       'style-loader', // 将 js 中的css代码通过创建style标签添加到html文件中使样式生效；
                       'css-loader', // 将 css 资源编译成 commonjs 的模块到js 中；
                     ]
                 }
     		]
     	}
     }
     ```

     - 处理图片资源

       - 过去在 Webpack4 时，我们处理图片资源通过 `file-loader` 和 `url-loader` 进行处理，现在 Webpack5 已经将两个 Loader 功能内置到 Webpack 里了，我们只需要简单配置即可处理图片资源，不需要安装loader；
       - 另外，对于较小的图片可以将其转换成base64格式的字符串，减少浏览器请求，优化性能；
       - 可以设置生成的图片名字以及打包输出的图片所在的目录，做到**打包输出的文件归类放置**；

       ```
       module.export = {
       	module: {
       		rules: [
       			{
                       test: /\.(png|jpe?g|gif|webp)$/,
                       type: "asset",
                       parser: {
                         // 如果图片不大于100kb，将会被转化成base64格式的图片字符串
                         dataUrlCondition: {
                           maxSize: 100 * 1024 // 100kb
                         }
                       },
                       generator: {
                         // 设置生成的图片名字以及打包输出的图片所在的目录，做到打包输出的文件归类放置；
                         // hash 图片打包后会有一个唯一的id（图片默认情况下打包后的名字），这个id在webpack中被称为hash值；
                         // [hash:6] 表示取hash值的前六位最为图片的名字；
                         // ext 文件扩展名，之前是 .png 打包后 ext 还是 .png；
                         // query 查询参数，如果在url地址中写了其他参数，这里会携带上；
                         filename: 'static/images/[hash:6][ext][query]'
                       },
                   },
       		]
       	}
       }
       ```

       

     - 处理字体图标 以及 其他资源（不做资源内容的处理，原封不动的打包输出，例如音频、视频资源等）

       - 字体图标不需要转base64，因此配置属性 `type: "asset/resource"`  将文件原封不动的打包输出；

       ```
       module.export = {
       	module: {
       		rules: [
       			{
                       test: /\.(ttf|woff2?|mp3|mp4|avi)$/,
                       type: "asset/resource", // 将文件原封不动的打包输出
                       generator: {
                         // 设置打包输出的文件名字以及打包输出的文件所在的目录
                         filename: 'static/media/[hash:6][ext][query]'
                       },
                    },
       		]
       	}
       }
       ```

       

       - 

     - 

       

   - 插件

     - 配置 HTML 模板

       - 之前我们是手动引入的打包后的 js 资源，但如果 webpack 配置中修改了 打包输出路径，还要手动修改 html 文件中引入的 js 路径；因此可以借助插件来实现打包后 js 文件的自动引入；

       - 使用方式：

         1. 安装插件   `npm install --save-dev html-webpack-plugin`  ;
         2. webpack 配置文件中配置插件

         ```
         const HtmlWebpackPlugin = require('html-webpack-plugin');
         
         module.exports = {
         // 插件
           plugins: [
             // 配置 HTML 模板，可以借助插件来实现打包后 js 文件的自动引入到 html 文件中
             new HtmlWebpackPlugin({
             	// 模板：以 public/index.html 为模板，创建新的html文件，并打包到 dist 文件下；
               	// 这个新的html文件有两个特点：1、DOM结构与模板中的一致；2、会自动引入打包后的资源；
               	template: './static/index.html',
             }),
           ],
         }
         ```

       

     - 

     ```
     module.export = {
         plugins: [
         	// 插件
         ]
     }
     ```

     

   - 模式

     - 模式有两种：development 和 production

     ```
     module.export = {
     	mode: 'development'
     }
     ```

     

3. 由于写了配置文件，因此可以直接执行 npx webpack  即可完成简单的打包；





--------------------

-----------------

-------------------



### Eslint

##### [官网](https://eslint.bootcss.com/docs/user-guide/configuring)

##### Eslint的配置文件

###### 配置文件由很多种写法：

1、新建文件，位于项目根目录

- `.eslintrc`
- `.eslintrc.js`
- `.eslintrc.json`
- 区别在于配置格式不一样

2、`package.json` 中 `eslintConfig`：不需要创建文件，在原有文件基础上写；

ESLint 会查找和自动读取它们，所以以上配置文件只需要存在一个即可；

###### 以 `.eslintrc.js` 语法为例，书写 Eslint 配置文件

```
module.exports = {
  // 解析选项
  parserOptions: {},
  // 具体检查规则
  rules: {},
  // 继承其他规则
  extends: [],
  // ...
  // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring
};
```

- parserOptions 解析选项

```
parserOptions: {
  ecmaVersion: 6, // ES 语法版本，表示ES6
  sourceType: "module", // ES 模块化
  ecmaFeatures: { // ES 其他特性
    jsx: true // 如果是 React 项目，就需要开启 jsx 语法
  }
}
```

- rules 具体规则
  1. `"off"` 或 `0` - 关闭规则
  2. `"warn"` 或 `1` - 开启规则，使用警告级别的错误：`warn` (不会导致程序退出)
  3. `"error"` 或 `2` - 开启规则，使用错误级别的错误：`error` (当被触发的时候，程序会退出)
  4. 更多规则详见：[规则文档](https://eslint.bootcss.com/docs/rules/)

```
rules: {
  semi: "error", // 禁止使用分号
  'array-callback-return': 'warn', // 强制数组方法的回调函数中有 return 语句，否则警告
  'default-case': [
    'warn', // 要求 switch 语句中有 default 分支，否则警告
    { commentPattern: '^no default$' } // 允许在最后注释 no default, 就不会有警告了
  ],
  eqeqeq: [
    'warn', // 强制使用 === 和 !==，否则警告
    'smart' // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告
  ],
}
```

- extends 继承

  开发中一点点写 rules 规则太费劲了，所以有更好的办法，继承现有的规则。现有以下较为有名的规则：

  1. [Eslint 官方的规则：`eslint:recommended`
  2. [Vue Cli 官方的规则](https://github.com/vuejs/vue-cli/tree/dev/packages/@vue/cli-plugin-eslint)：`plugin:vue/essential`
  3. [React Cli 官方的规则](https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app)：`react-app`

```
// 例如在React项目中，我们可以这样写配置
module.exports = {
  extends: ["react-app"], // 继承 react cli 官方的 Eslint规则
  rules: {
    // 我们的规则会覆盖掉react-app的规则
    // 所以想要修改规则直接改就是了
    eqeqeq: ["warn", "smart"], // 新增规则 或者 覆盖掉继承的规则
  },
};
```

##### webpack 处理 Eslint  代码

- Eslint 在 webpack4 中是用 loader 来处理的；但在 webpack5 中用 插件 处理的；

###### webpack5 用 插件 处理 Eslint

1. 安装  `npm i eslint-webpack-plugin eslint -D`  ；

2. webpack.config.js 配置

   ```
   # webpack.config.js 文件内
   const ESLintWebpackPlugin = require("eslint-webpack-plugin");
   
   plugins: [
       new ESLintWebpackPlugin({
         // 指定检查文件的根目录
         context: path.resolve(__dirname, "src"),
       }),
   ],
   ```

3. 在文件根目录创建 Eslint 的配置文件（以 .eslintrc.js 为例）

   ```
   // 以下eslint配置举例
   module.exports = {
     // 继承 Eslint 规则
     extends: ["eslint:recommended"], // 继承 Eslint 官方的规则
     // 环境变量
     env: {
       node: true, // 启用node中全局变量
       browser: true, // 启用浏览器中全局变量，比如：window、console等
     },
     parserOptions: {
       ecmaVersion: 6, // 语法环境：ES6
       sourceType: "module", // ES module
     },
     rules: {
       "no-var": 2, // 不能使用 var 定义变量，否则报错误级别的错误，2 等同于 error
     },
   };
   ```

4. 如果代码中使用  var  来声明变量，如果 vscode 没有安装 Eslint 插件，则会在编译代码时报错；如果 vscode 安装了 eslint 插件，则会在书写代码时就会报错，因此建议在 vscode 中安装 eslint 插件；

5. `.eslintignore`  文件，用于配置 Eslint 忽略检查的文件；比如：通过webpack打包后的dist文件内不需要被eslint检查，因此可忽略；

   ```
   // .eslintignore 文件内
   # 忽略dist目录下所有文件
   dist
   ```

   

6. 可以在  settings.json  文件内配置是否在保存时修复 eslint 发现的语法错误；

   ```
   // settings.json 文件内
   {
   	"liveServer.settings.donotShowInfoMsg": true,
   	"explorer.confirmDelete": false,
   	"emmet.excludeLanguages": ["markdown"],
   	"liveServer.settings.host": "192.168.37.60",
   	"explorer.confirmDragAndDrop": false,
   	"workbench.editor.enablePreview": false,
   	"cssrem.rootFontSize": 80,
   	"window.zoomLevel": 2,
   	"editor.minimap.enabled": false,
   	"[vue]": {
   		"editor.defaultFormatter": "octref.vetur"
   	},
   	"[javascript]": {
   		"editor.defaultFormatter": "vscode.typescript-language-features"
   	},
   	"eslint.validate": ["javascript", "javascriptreact"],
   	"vetur.ignoreProjectWarning": true,
   	"vetur.format.defaultFormatter.js": "vscode-typescript",
   	"vetur.format.defaultFormatter.html": "js-beautify-html",
   	"vetur.format.defaultFormatterOptions": {
   
   		"js-beautify-html": {
   			"wrap_line_length": 80, // Wrap attributes to new lines [auto|force|force-aligned|force-expand-multiline] ["auto"]
   			// "wrap_attributes": "force-expand-multiline" // DOM 标签超过两个换行
   		}
   	},
   	"editor.tabSize": 2,
   	"git.ignoreLimitWarning": true,
   	"editor.codeActionsOnSave": {
   		"source.fixAll.eslint": true, // 保存时是否自动修复eslint检测报错的代码
   	},
   	"git.confirmSync": false,
   	"eslint.quiet": true,
   	"javascript.format.insertSpaceBeforeFunctionParenthesis": true,
   	"typescript.format.insertSpaceAfterConstructor": true,
   	"typescript.format.insertSpaceBeforeFunctionParenthesis": true,
   	"javascript.preferences.quoteStyle": "single",
   	"javascript.format.insertSpaceAfterConstructor": true,
   	"typescript.preferences.quoteStyle": "single",
   	// "html.format.wrapAttributes": "force-expand-multiline", // DOM 标签超过两个换行
   	"editor.formatOnSave": true,
   	"prettier.vueIndentScriptAndStyle": true,
   	"prettier.singleQuote": true,
   	"prettier.useTabs": true,
   	"prettier.printWidth": 100,
   	"eslint.workingDirectories": [
   		".eslintrc.js",
   		{
   			"mode": "auto"
   		}
   	],
   	"[json]": {
   		"editor.defaultFormatter": "esbenp.prettier-vscode"
   	},
   	"editor.fontSize": 12,
   	"[html]": {
   		"editor.defaultFormatter": "vscode.html-language-features"
   	},
   	"javascript.updateImportsOnFileMove.enabled": "always",
   	"vetur.validation.template": false,
   	"eslint.codeActionsOnSave.rules": null
   }
   
   ```






----

----

---



### Babel

##### [官网](https://babeljs.io/docs/en/)

- JavaScript 编译器。主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中；
- [babel](https://links.jianshu.com/go?to=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2F)是一个JS编译器，用来将ES6/ES7等语法转换为ES5语法（浏览器不认识的语法编译成浏览器认识的语法），从而能够使代码在大部分浏览器中运行。但是babel转换语法时有一些新的api是不转化的，比如promise、Object.assign等，所以babel还提供了很多插件，如babel-polyfill。
- **webpack和babel通常配合起来使用，babel是js编译工具,能将es6或者一些特殊语法做一些转换，只做文件转义，不做文件整合。webpack是一个打包工具，内置只能处理js，但是它可以加载很多的loader处理css,img,ts,vue等其他文件,最终输出js文件。webpack通过使用babel-loader使用Babel 。**

##### Babel 的配置文件

###### Babel 的配置文件由很多种写法：Babel 会查找和自动读取它们，所以以下配置文件只需要存在一个即可

1. 新建文件，位于项目根目录
   - `babel.config.js`
   - `babel.config.json`
   - `.babelrc`
   - `.babelrc.js`
   - `.babelrc.json`
2. 不需要创建文件，在原有文件基础上写
   - `package.json`  中 `babel` ；

###### 以 `babel.config.js` 配置文件为例

```
module.exports = {
	// 预设
  	presets: ["@babel/preset-env"],
};
```

- presets 预设，简单理解：就是一组 Babel 插件, 扩展 Babel 功能；
  1. `@babel/preset-env`: 一个智能预设，允许您使用最新的 JavaScript ；
  2. `@babel/preset-react`：一个用来编译 React jsx 语法的预设 ；
  3. `@babel/preset-typescript`：一个用来编译 TypeScript 语法的预设 ；

##### webpack 处理 Babel 代码

###### webpack5 用 loader 处理 Babel 代码

1. 下载包

   ```
   npm i babel-loader @babel/core @babel/preset-env -D
   ```

2. 定义 Babel 配置文件，以 `babel.config.js` 配置文件为例

   ```
   module.exports = {
   	// 预设
     	presets: ["@babel/preset-env"],
   };
   ```

3. 在 webpack 的配置文件中配置 loader 处理 Babel 代码

   ```
   module: {
       rules: [
       	{
               test: /\.js$/,
               exclude: /node_modules/, // 排除 node_modules 代码不编译
               loader: "babel-loader",
               // options: {
               // 		presets: ["@babel/preset-env"],  // 如果在 webpack 的配置文件中添加了babel预设的配置，就不需要在 外面的 babel 配置文件中再配置了；
               // },
           },
       ]
   }
   ```

4. webpack 重新编译，执行 `npx webpack ` ；查看效果：例如：函数形参中 扩展运算符 改为 arguments 接收参数；



---

---

---



### 开发服务器&自动化

- 每次写完代码都需要手动输入指令 `npx webpack` 才能编译代码，太麻烦了，我们希望一切自动化；

##### 使用：

1. 安装： `npm i webpack-dev-server -D` ;

2. 在webpack中配置

   ```
   module.exports = {
   	// 开发服务器，需要运行 npx webpack serve 才能启动开发服务器，不会生成打包后的文件，而是在内存中编译打包的，而且修改完代码后自动打包且更新浏览器展示
       devServer: {
           host: "localhost", // 启动服务器域名
           port: "3000", // 启动服务器端口号
           open: true, // 是否自动打开浏览器
       },
   }
   ```

3. 运行指令 `npx webpack serve`  ，运行旧指令是不会启动开发服务器的，**注意：新指令不会生成打包后的文件，而是在内存中编译打包的，而且修改完代码后自动打包且更新浏览器展示；**





---

---

---



### 生产模式下webpack配置

##### 生产模式下的webpack配置文件调整

###### 代码中调整步骤：

1. 根目录新建 config 文件夹，将webpack的配置文件（生产模式下仿照开发模式下的配置文件进行配置）移入到 config 文件内；

2. 调整 两种模式下的 webpack 配置文件内的路径；

   - 相对路径不用调整，因为webpack的配置文件运行时还是在根目录；
   - 绝对路径需要加上 `../` ；

3. 对于开发模式下的webpack配置文件的调整：

   - 绝对路径需要加上 `../` ；
   - 输出路径改为` path: undefined `，也可以不改；（ 配置了开发服务器后，不会真正的有文件输出，而是在内存中打包的，因此可以不写输出路径，也不需要配置clean来清空上次打包内容，但是输出文件名要写）
   - 执行指令 `npx webpack serve --config ./config/webpack.dev.js`  打包并自动运行到浏览器；

4. 对于生产模式下的webpack配置文件的调整：

   - 绝对路径需要加上 `../` ；
   - 生产模式不需要devServer（配置的开发服务器），要删掉；
   - ` mode: production` ;
   - 执行指令  `npx webpack --config ./config/webpack.prod.js`  打包；

5. 在 `package.json` 文件内配置运行脚本指令快捷键；

   ```
   "scripts": {
       "start": "npm run dev", // 直接执行 npm start 即可运行开发模式的项目打包；
       "dev": "webpack serve --config ./config/webpack.dev.js", // 开发模式的项目打包；
       "build": "webpack --config ./config/webpack.prod.js" // 生产模式的项目打包；
   },
   ```

##### 提取 css 成单独的文件

- Css 文件目前被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式，这样对于网站来说，会出现闪屏现象，用户体验不好；我们应该是单独的 Css 文件，通过 link 标签加载性能才好；

- MiniCssExtractPlugin 插件的使用：

  1. 安装包

     ```
     npm i mini-css-extract-plugin -D
     ```

  2. webpack.prod.js 文件内使用该插件：

     ```
     # 1、引入
     const MiniCssExtractPlugin = require("mini-css-extract-plugin");
     
     # 2、删掉module中的 style-loader 改成 MiniCssExtractPlugin.loader；例如：
     module: {
         rules: [
           {
             // 用来匹配 .css 结尾的文件
             test: /\.css$/,
             use: [
             	"style-loader", // 这个loader会动态创建style标签，将 js 中的css代码通过创建的style标签添加到html文件中使样式生效；
                 MiniCssExtractPlugin.loader, // 把css文件提取成单独的文件，所以不需要引入style-loader来创建style标签了；
                 "css-loader"
             ],
           },
         ],
     }
     
     # 3、配置plugins
     plugins: [
     	// 提取css成单独文件，并结合 HtmlWebpackPlugin 插件，可以实现打包后 css 自动通过 link 标签引入到 html 文件中；
         new MiniCssExtractPlugin({
           // 定义输出文件名和目录
           filename: "static/css/main.css",
         }),
     ]
     ```

##### css 兼容性处理

- js 的兼容性问题（ES6+ => ES5）由 babel 处理，而样式也有兼容性问题，比如浏览器的兼容；

-  postcss-loader 的使用步骤：

  1. 安装包

     ```
     npm i postcss-loader postcss postcss-preset-env -D
     ```

  2. webpack.prod.js 文件内使用该loader：

     ```
     module: {
         rules: [
         	{
                 test: /\.less$/,
                 use: [
                   MiniCssExtractPlugin.loader,
                   "css-loader",
                   // postcss-loader 必须使用在  "css-loader"  之前，且在  "less-loader"  等loader之后；
                   // 如果loader需要额外的配置，需要将该loader写成对象的形式；
                   {
                     loader: "postcss-loader",
                     options: {
                       postcssOptions: {
                         plugins: [
                           "postcss-preset-env", // 能解决大多数样式兼容性问题
                         ],
                       },
                     },
                   },
                   "less-loader",
                 ],
             },
         ]
     }
     ```

  3. **注意：postcss-loader 必须使用在  "css-loader"  之前，且在  "less-loader"  等loader之后；**

  4. 可以用 user-select 进行测试；

     ```
     // 打包后生成的兼容性样式
     -webkit-user-select: none;
     -moz-user-select: none;
     user-select: none;
     ```

- 配置浏览器兼容程度：

  - 可以在 `package.json` 文件中添加 `browserslist` 来控制样式的兼容性做到什么程度；更多的 `browserslist` 配置，查看[browserslist 文档](https://github.com/browserslist/browserslist) ；

  ```
  // 比较常见的浏览器兼容程度的配置
  {
    // 满足以下条件的交集的浏览器才做兼容
    "browserslist": [
        "last 2 version",  // 所有浏览器最近的两个版本
        "> 1%",  // 市场占有率大于1%的浏览器
        "not dead" // 还在维护的浏览器
    ]
  }
  ```

##### css 压缩

- CssMinimizerWebpackPlugin 插件的使用步骤：

  1. 安装包

     ```
     npm install css-minimizer-webpack-plugin --save-dev
     ```

  2. webpack.prod.js 中使用

     ```
     const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
     
     // 插件
     plugins: [
     	// css压缩
         new CssMinimizerPlugin(),
     ]
     ```

##### html 、js 压缩

- 只要设置 mode 为 production 生产模式，默认开启 html 压缩 和 js 压缩，不需要额外配置；



----

----

----

# webpack高级

## 提升开发体验

### SourceMap（源代码映射）

##### 查看[Webpack DevTool 文档](https://webpack.docschina.org/configuration/devtool/)

- SourceMap（源代码映射）是一个用来生成源代码与构建后代码一一映射的文件的方案。
- 它会生成一个 xxx.map 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。当构建后代码出错了，会通过 xxx.map 文件，从构建后代码出错位置找到映射后源代码出错位置，从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源。

##### 使用：

- 开发模式：`cheap-module-source-map`

  - 优点：打包编译速度快，只包含行映射；
  - 缺点：没有列映射；

  ```
  module.exports = {
    // 其他省略
    mode: "development",
    devtool: "cheap-module-source-map",
  };
  ```

- 生产模式：`source-map`

  - 优点：包含行/列映射，因为生产模式下打包后的文件是被压缩的，只有一行，因此要定位错误代码位置，需要精确到列；
  - 缺点：打包编译速度更慢；

  ```
  module.exports = {
    // 其他省略
    mode: "production",
    devtool: "source-map",
  };
  ```



## 提升打包构建速度

### HotModuleReplacement 热替换（只针对开发模式）

- 开发时我们修改了其中一个模块代码，Webpack 默认会将所有模块全部重新打包编译，速度很慢。所以我们需要做到修改某个模块代码，就只有这个模块代码需要重新打包编译，其他模块不变，这样打包速度就能很快。
- HotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。

##### 使用

###### 对于 css 样式

- 由于 css 样式经过 style-loader 的处理，已经具备 HMR 功能了，因此，只需要在webpack配置文件中开启即可；

```
module.exports = {
  // 其他省略
  devServer: {
    host: "localhost", // 启动服务器域名
    port: "3000", // 启动服务器端口号
    open: true, // 是否自动打开浏览器
    hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了）
  },
};
```

###### 对于 js 

- 如果我们自己写的 js 项目，需要在 main.js 文件内监听模块的变化；

  **各个文件模块的监听的回调不会相互影响；哪一个模块发生变化，就执行哪一个回调；**

  ```
  # main.js 文件内
  
  // 判断是否支持HMR功能
  if (module.hot) {
    // 回调函数可以不写，也会只更新这个count.js文件模块
    module.hot.accept("./js/count.js", function (count) {
    	// count.js 文件修改后，要执行的回调函数
      const result1 = count(2, 1);
      console.log(result1);
    });
    // 回调函数可以不写，也会只更新这个sum.js文件模块
    module.hot.accept("./js/sum.js", function (sum) {
      const result2 = sum(1, 2, 3, 4);
      console.log(result2);
    });
  }
  ```

- 但是在我们实际开发中，通常借助 vue 或 react 框架，它们有自带的 [vue-loader](https://github.com/vuejs/vue-loader) 和 [react-hot-loader](https://github.com/gaearon/react-hot-loader) ；因此跟css一样只需要在 webpack 配置文件中开启 HMR 功能即可自动实现模块的热替换；



### OneOf

- 打包时每个文件都会经过所有 loader 处理，虽然因为 `test` 正则原因实际没有处理上，但是都要过一遍。比较慢。
- OneOf 只能匹配上一个 loader, 剩下的就不匹配了。

##### 使用（生产和开发模式都要配置）

- 在所有的 loader 对象外面包一层 oneOf 数组即可；

```
# webpack 的配置文件内

module.exports = {
	module: {
        rules: [
              {
                 oneOf: [
                      {
                          // 用来匹配 .css 结尾的文件
                          test: /\.css$/,
                          // use 数组里面 Loader 执行顺序是从右到左
                          use: ["style-loader", "css-loader"],
                      },
                      {
                          test: /\.less$/,
                          use: ["style-loader", "css-loader", "less-loader"],
                      },
                      // 其他loader省略
                 ]
             }
        ],
    }
}
```



### Include/Exclude

- 开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中了。而这些文件是不需要编译可以直接使用的。
- 所以我们在对 js 文件处理时，要排除 node_modules 下面的文件，例如 eslint 、babel 处理时要排除。
- **注意：include 和 exclude 不可以同时使用，只写一个即可**；

##### 用法

-  eslint 、babel 处理 js 文件时排除 node_modules 下面的文件；（生产模式和开发模式都要配置）

```
# webpack 的配置文件内

module.exports = {
	module: {
		// webpack5 用 loader 处理 Babel 代码
        {
          test: /\.js$/,
          // exclude: /node_modules/, // 排除 node_modules 代码不编译；include、exclude不能同时使用；
          include: path.resolve(__dirname, '../src'), // 只处理 src 下的文件；include、exclude不能同时使用；
          loader: "babel-loader",
          // options: {
          //   presets: ["@babel/preset-env"], // 如果在 webpack 的配置文件中添加了babel预设的配置，就不需要在 外面的 babel 配置文件中再配置了；
          // }
        }
	},
	// 插件
    plugins: [
        // 用于处理 Eslint 的插件
        new ESLintWebpackPlugin({
            // Eslint的配置选项，指定检查文件的根目录
            context: path.resolve(__dirname, "../src"), // 哪些文件要做Eslint检查，检查src文件下的所有文件
            exclude: "node_modules", // （默认值）排除 node_modules 代码不编译；include、exclude不能同时使用；
            // include: path.resolve(__dirname, '../src'), // 只处理 src 下的文件；include、exclude不能同时使用；
        }),
    ]
}
```



### Cache 缓存

- 每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时只需要检查和编译被修改的文件即可，速度就会更快了。

##### 用法

- 打包后，会把  Eslint 检查 和 Babel 编译结果的缓存文件 添加到  `node_modules/.cache`  文件夹下；

```
# webpack 的配置文件内

module.exports = {
	module: {
		// webpack5 用 loader 处理 Babel 代码
        {
          test: /\.js$/,
          // exclude: /node_modules/, // 排除 node_modules 代码不编译；include、exclude不能同时使用；
          include: path.resolve(__dirname, '../src'), // 只处理 src 下的文件；include、exclude不能同时使用；
          loader: "babel-loader",
          options: {
          	// presets: ["@babel/preset-env"], // 如果在 webpack 的配置文件中添加了babel预设的配置，就不需要在 外面的 babel 配置文件中再配置了；
          	cacheDirectory: true, // 开启babel编译缓存
            cacheCompression: false, // 缓存文件不要压缩
          }
        }
	},
	// 插件
    plugins: [
        // 用于处理 Eslint 的插件
        new ESLintWebpackPlugin({
            // Eslint的配置选项，指定检查文件的根目录
            context: path.resolve(__dirname, "../src"), // 哪些文件要做Eslint检查，检查src文件下的所有文件
            exclude: "node_modules", // （默认值）排除 node_modules 代码不编译；include、exclude不能同时使用；
            // include: path.resolve(__dirname, '../src'), // 只处理 src 下的文件；include、exclude不能同时使用；
            cache: true, // 开启缓存
            cacheLocation: path.resolve(__dirname, "../node_modules/.cache/.eslintcache"), // 缓存目录
        }),
    ]
}
```



### Thead 多进程打包

- 对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，Terser 就是在生产模式下，webpack会自动使用这个插件来压缩 js 代码；
- 之前打包的过程都是使用一个进程，速度比较慢，因此可以开启 多进程打包：开启电脑的多个进程同时干一件事，速度更快。
- **注意：请仅在特别耗时的操作（项目比较大）中使用，因为每个进程启动就有大约为 600ms 左右开销。**

##### 使用（生产和开发都配置）

1. 先获取 CPU 的核数，因为启动进程的最大数量就是我们 CPU 的核数。

   ```
   // nodejs核心模块，直接使用
   const os = require("os");
   // cpu核数
   const threads = os.cpus().length;
   ```

2. 安装包

   ```
   npm i thread-loader -D
   ```

3. webpack 的配置文件中使用，由于是 js 文件打包比较耗时，因此在 处理 js 文件的 babel 和 eslint 上配置多进程；

   ```
   // 压缩 js 代码的插件，不需要安装，内置模块
   const TerserPlugin = require("terser-webpack-plugin");
   // nodejs核心模块，直接使用
   const os = require("os");
   // cpu核数
   const threads = os.cpus().length;
   
   module.exports = {
   	// 加载器
       module: {
           rules: [
           	{
                   oneOf: [
   					  // webpack5 用 loader 处理 Babel 代码
                         {
                           test: /\.js$/,
                           // exclude: /node_modules/, // 排除 node_modules 代码不编译；include、exclude不能同时使用；
                           include: path.resolve(__dirname, '../src'), // 只处理 src 下的文件；include、exclude不能同时使用；
                           use: [
                             {
                               loader: "thread-loader", // 开启多进程
                               options: {
                                 workers: threads, // 开启多线程的数量，就是 CPU 的核数；
                               },
                             },
                             {
                               loader: "babel-loader",
                               options: {
                                 // presets: ["@babel/preset-env"], // 如果在 webpack 的配置文件中添加了babel预设的配置，就不需要在 外面的 babel 配置文件中再配置了；
                                 cacheDirectory: true, // 开启babel编译缓存
                                 cacheCompression: false, // 缓存文件不要压缩
                               }
                             }
                           ],
                         }
                   ]
                }
           ]
       }
   	// 插件
     	plugins: [
           // 用于处理 Eslint 的插件
           new ESLintWebpackPlugin({
             // Eslint的配置选项，指定检查文件的根目录
             context: path.resolve(__dirname, "../src"), // 哪些文件要做Eslint检查，检查src文件下的所有文件
             exclude: "node_modules", // （默认值）排除 node_modules 代码不编译；include、exclude不能同时使用；
             // include: path.resolve(__dirname, '../src'), // 只处理 src 下的文件；include、exclude不能同时使用；
             cache: true, // 开启缓存
             // 缓存目录
             cacheLocation: path.resolve(__dirname, "../node_modules/.cache/.eslintcache"),
             threads, // 开启多进程
           }),
   
           // 配置 HTML 模板，可以借助插件来实现打包后 js 文件的自动引入到 html 文件中
           new HtmlWebpackPlugin({
             // 模板：以 public/index.html 为模板，创建新的html文件，并打包到 dist 文件下；
             // 这个新的html文件有两个特点：1、DOM结构与模板中的一致；2、会自动引入打包后的资源；
             template: path.resolve(__dirname, '../public/index.html'), // html模板路径可以为相对路径或者绝对路径；
           }),
           // 提取css成单独文件，并结合 HtmlWebpackPlugin 插件，可以实现 css 自动通过 link 标签引入到 html 文件中；
           new MiniCssExtractPlugin({
             // 定义输出文件名和目录
             filename: "static/css/main.css",
           }),
   
           // css压缩 （可以写到optimization.minimizer里面，效果一样的）
           // new CssMinimizerPlugin(),
   
   		// js压缩
           // 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了
           // （可以写到optimization.minimizer里面，效果一样的）
           // new TerserPlugin({
           //   parallel: threads // 开启多进程
           // })
       ],
       
       // 一般压缩的内容放在这里
   	optimization: {
           minimize: true,
           minimizer: [
             // css压缩 （可以写在插件plugins里面，效果一样的）
             new CssMinimizerPlugin(),
             // js压缩
             // 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了
             // （可以写在插件plugins里面，效果一样的）
             new TerserPlugin({
               parallel: threads // 开启多进程
             })
           ],
       },
   }
   ```





---

---

---



## 减少打包后代码体积

### Tree Shaking

- 开发时我们定义了一些工具函数库，或者引用第三方工具函数库或组件库。如果没有特殊处理的话我们打包时会引入整个库，但是实际上可能我们可能只用上极小部分的功能。这样将整个库都打包进来，体积就太大了。
- `Tree Shaking` 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码；**打包时会自动移除没有使用的代码，比如某个 js 文件中没有使用的函数等。**
- **注意：它依赖 `ES Module`。**
- **生产模式下 Webpack 已经默认开启了这个功能，无需其他配置。**



## Babel 插件配置

- Babel 为编译的每个文件都插入了辅助代码，使代码体积过大！

  Babel 对一些公共方法使用了非常小的辅助代码，比如 `_extend`。默认情况下会被添加到每一个需要它的文件中。

  你可以将这些辅助代码作为一个独立模块，来避免重复引入。

- `@babel/plugin-transform-runtime` 的作用 :   禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 `@babel/plugin-transform-runtime` ，并且使所有辅助代码从这里引用，从而减少打包后代码体积。

##### 使用（开发和生产）

1. 安装包

   ```
   npm i @babel/plugin-transform-runtime -D
   ```

2. 给 Babel 的 loader 配置插件

   ```
   module: {
       rules: [
         {
           oneOf: [
           	{
                   test: /\.js$/,
                   // exclude: /node_modules/, // 排除node_modules代码不编译
                   include: path.resolve(__dirname, "../src"), // 也可以用包含
                   use: [
                     {
                       loader: "thread-loader", // 开启多进程
                       options: {
                         workers: threads, // 数量
                       },
                     },
                     {
                       loader: "babel-loader",
                       options: {
                         cacheDirectory: true, // 开启babel编译缓存
                         cacheCompression: false, // 缓存文件不要压缩
                         plugins: ["@babel/plugin-transform-runtime"], // Babel 插件配置,减少代码体积
                       },
                     },
                   ],
               },
           ]
         }
       ]
   }
   ```

   

### Image Minimizer  图片压缩

- 开发如果项目中引用了较多图片，那么图片体积会比较大，将来请求速度比较慢。

  我们可以对图片进行压缩，减少图片体积。

  **注意：如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。**

- `image-minimizer-webpack-plugin`:  用来压缩图片的插件

##### 使用（开发和生产）

1. 安装包（经常安装失败）

   - [有损/无损压缩的区别](https://baike.baidu.com/item/无损、有损压缩)

   ```
   # 用来压缩图片的插件
   npm i image-minimizer-webpack-plugin imagemin -D
   
   # 无损压缩（两种压缩模式选一种）
   npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D
   
   # 有损压缩（两种压缩模式选一种）
   npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D
   ```

2. 配置，我们以无损压缩配置为例：

   ```
   const ImageMinimizerPlugin = require("image-minimizer-webpack-plugin");
   
   // 压缩的配置一般放在这里，也可以放在插件plugins里
   optimization: {
       minimizer: [
         // 压缩图片
         new ImageMinimizerPlugin({
           minimizer: {
             implementation: ImageMinimizerPlugin.imageminGenerate,
             options: {
               plugins: [
                 ["gifsicle", { interlaced: true }],
                 ["jpegtran", { progressive: true }],
                 ["optipng", { optimizationLevel: 5 }],
                 [
                   "svgo",
                   {
                     plugins: [
                       "preset-default",
                       "prefixIds",
                       {
                         name: "sortAttrs",
                         params: {
                           xmlnsOrder: "alphabetical",
                         },
                       },
                     ],
                   },
                 ],
               ],
             },
           },
         }),
       ]
   }
   ```

3. 打包时会出现报错：如果提示需要安装两个文件到 node_modules 中才能解决， 文件可以从课件中找到：

   - jpegtran.exe  需要复制到 `node_modules\jpegtran-bin\vendor` 下面；[jpegtran 官网地址](http://jpegclub.org/jpegtran/)
   - optipng.exe  需要复制到 `node_modules\optipng-bin\vendor` 下面；[OptiPNG 官网地址](http://optipng.sourceforge.net/)

 
